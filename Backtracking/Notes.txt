
# Logcat Analysis

```bash
$ adb logcat | grep -i <PID> => This code will show you all the logs of the app with the PID that you specified.

- You can search for an access token, a password, a username, or any other sensitive information that the app is logging.

- Access token is a token that is used to authenticate a user to an API. If you find an access token in the logs, you can use it to authenticate yourself to the API.

- Use JWT to decode the access token and stract the information.

- Now you can use to access other endpoints of the API, like force an login in another account, or access sensitive information.

- Access token can also been seen in /data/data/<app>/shared_prefs/<app>.xml with "& adb shell", if a developer is storing the token in the shared preferences.



```


# Bypass Root Detection
This section of code is a attack to bypass the root detection in an Android app. The app is a simple app that checks if the device is rooted, and if it is, it will not run. 
The goal is to bypass this check and make the app run in a rooted device. (like a virtual device).
```
$ apt install dex2jar
$ d2j-dex2jar <app>.apk => This code will transform the .apk file into a .jar file, decoding bytecode into Java code.
$ apt install jd-gui    => This code will install the Java Decompiler GUI. 
$ jd-gui <app>.apk      => An interface that will allow you to view the Java code. 

$ apt install apktool  => Apktool is a tool for reverse engineering 3rd party, closed, binary Android apps. It can decode resources to nearly original form and rebuild them after making some modifications.
$ apktool d <app>.apk  => This code will decode the .apk file into a folder with the same name as the .apk file. On a smali folder, you will find the .smali files, which are the disassembled code of the app. 

- You have access to AndroidManifest.xml, which is the file that contains the app's configuration.
- Now you can modify the code and rebuild the app. Other thing is to use the apktool to build the app again.
- apktool b <app> => This code will build the app again, and you will find the new .apk file in the dist folder.

$ cat AndroidManifest.xml | grep -i "activity" => This code will show you all the activities that the app has.
$ cat AndroidManifest.xml | grep -i "intent-filter" => This code will show you all the activities that have an intent-filter, which means that they are exported and can be accessed from other apps.
$ cat AndroidManifest.xml | grep -i "permission" => This code will show you all the permissions that the app has.
$ cat AndroidManifest.xml | grep -i "provider" => This code will show you all the content providers that the app has.

$ grep -ir isdevicerooted => We have .smile of each Java Class, so we can search for strings in the code. This code will show you all the classes that have the string "isdevicerooted". In order to bypass this check, and enable an app run in a virtual environment
Output: smali_classesx/com/xxx/xxx/xxx.smali:    const-string v0, "isdevicerooted"

!Erase the folder generated by the apktool, and run again:
$ apktool d -f -r <app>.apk => This code will decode the .apk file into a folder with the same name as the .apk file, and it will force the decoding, even if the folder already exists. The -r flag will ignore the resources when decoding the app.~

$ grep -ir isdevicerooted
$ nano smali_classesx/com/xxx/xxx/xxx.smali
- Change in isDeviceRooted method, the return-const/4 v0, 0x1 to return-const/4 v0, 0x0. This is setting the return value to 0, which means false.
- Save the file and run the apktool to build the app again.
$ apktool b <app> -o <new_app>.apk 

- Now you need assign the permissions to the new app.

$ keytool -genkey -keystore <my-release-key>.jks -alias <alias_name> -keyalg RSA -keysize 2048 -validity 10000 => This code will generate a keystore file, which is a file that contains the private key that you will use to sign the app. The -alias flag is the name of the key, and the -validity flag is the number of days that the key will be valid.

$ apt install apksigner => This code will install the apksigner tool, which is a tool that you can use to sign the app.
$ apksigner sign --ks <my-release-key>.jks --out <signed_new_app>.apk <new_app>.apk => This code will sign the app with the keystore file that you generated before.

$ apksigner verify <signed_new_app>.apk => This code will verify if the app is signed correctly.
```


# Bypass SSL Pinning
This section of code is an attack to bypass the SSL Pinning in an Android app. The app is a simple app that checks if the certificate is valid, and if it is not, it will not run.
The goal is to bypass this check and make the app run even if the certificate is not valid.
**SSL Pinning is a security measure that avoid the app to run if the certificate is not valid. The app will only run if the certificate is the one that the developer specified. This also
avoids reading the traffic between the app and the server.**
```
$ grep -ir "sslcontext" => We have .smile of each Java Class, so we can search for strings in the code. This code will show you all the classes that have the string "sslcontext". In order to bypass this check, and enable an app run in a virtual environment
Output: smali_classesx/com/xxx/xxx/xxx.smali:    const-string v0, "sslcontext"
$ grep -ir "sslcontext"
$ nano smali_classesx/com/xxx/xxx/xxx.smali
- Change in the method that checks the certificate, the return-const/4 v0, 0x1 to return-const/4 v0, 0x0. This is setting the return value to 0, which means false.
- Save the file and run the apktool to build the app again.
$ apktool b <app> -o <new_app>.apk
```


Frida is a dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers. It allows you to inject your own scripts into black box processes.
This process will create a java Hook to bypass the root detection in an Android app.
An java hook is a way to intercept the execution of a method in a Java class. You can use a hook to change the behavior of the method, log the arguments of the method, or even change the return value of the method.
[Frida Download](https://frida.re/docs/installation/)
[Frida Realeases](https://github.com/frida/frida/releases)
```
$ pip3 install frida frida-tools
$ adb push xxx/frida-server-xx.x.x-android-x86 /tmp 
$ adb shell
$ cd /tmp
$ chmod +x frida-server-xx.x.x-android-x86
$ ./frida-server-xx.x.x-android-x86 &
$ frida-ps -U => This code will show you all the processes that are running in the device. Celphone is a server and the hacker is a client. Type this code in the hacker's terminal. -U flag is to show the processes of the USB connected device.
$ frida -ps -Ua => All services that are opened in the device.
$ frida -U -l <hook.js> -f <app> => This code will run the hook.js script in the app process. The -U flag is to specify that the device is connected via USB, and the -l flag is to specify the script that you want to run. The -f flag is to specify the app that you want to run the script in.

$ pip3 install objection
$ objection --gadget "com.xxx.xxx" explore => This code will open the objection console in the app process. The --gadget flag is to specify the app that you want to open the console in, and the explore command is to open the console.

- Now you can use the objection console to interact with the app process. You can use the console to run Frida scripts, dump the memory of the app, or even change the behavior of the app.

$ android sslpinning disable => This code will disable the SSL pinning in the app. The --gadget flag is to specify the app that you want to disable the SSL pinning in, and the android sslpinning disable command is to disable the SSL pinning.
$ android sslpinning bypass => This code will bypass the SSL pinning in the app. The --gadget flag is to specify the app that you want to bypass the SSL pinning in, and the android sslpinning bypass command is to bypass the SSL pinning.
$ android root disable => This code will disable the root detection in the app. The --gadget flag is to specify the app that you want to disable the root detection in, and the android root disable command is to disable the root detection.

- In case of failure in the previous command, you can use your own script to bypass the root detection.
$ import <exploit.js> 
$ objection --gadget "com.xxx.xxx" explore -s "/xxx/xxx/xxx/exploit.js" => This code will run the exploit.js script in the app process. The --gadget flag is to specify the app that you want to run the script in, and the explore command is to open the console. The -s flag is to specify the script that you want to run.
```

